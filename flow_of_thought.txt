10: jump 한 줄
{
2t줄:  data
1줄:   상수 jump
t-1줄: code
1줄:   상수 jump
}

R1 = free space, 1 or 8 (상수)
R2 = free space
R3 = t (상수)
R4 = 반복할 남은 횟수
R5 = 데이터로 건너갈 위치, 초깃값 11

-------------------------------------------------

set R3 = 3t + 1
set R4 = ??
set R5 = 11
set R1 = instruction at 10
print R1
goto using E (R5 참고) (ㄱ)
R5 += R3
(8t개의 명령으로 출력 가능)
print constant jump
set R1 = 8
(3t개의 명령으로 출력 가능)
set R1 = 1
R4 -= R1
goto using D (ㄱ으로)

-------------------------------------------------

일단 f(x) = (20+11x)(3x+1)/(x-1)으로 근사했을 때 apprantely x=3으로 하는 게 최선이네...
실제로 계산을 해서 작게 만들 수 있으면 좋을 텐데...

자, 그럼 다시 써보자. 참고로 RA, RB, RC, RD, RE, RF만 이용하면 된다. 

10: jump to 18, 즉 C0!!
{
6줄: registry에 저장. 
1줄: jump to 
2줄: code
1줄: jump to 
}

code 부분만 모았을 때: 

set R1 = 1
set R2 = 8
set R3 = A
set R4 = ??
set R5 = 11
set R6 = C0
set R6 = R6 << 8
set R7 = !!
set R8 = []
R9 = R6 + R7 (즉, R9가 C0!!이 됨)
99FF (print 10:)
E500 (R5 자리, 즉 data 자리로 ㄱㄱ, 이제 다음으로 돌아오면 RA~RF가 잘 차 있음) ([])
1553 (R5 증가시켜주기)
(이제, 24개의 명령으로 data를 출력해준다.)
set R9 = R6 + R8
96FF (data에서 code로 넘어오는 부분 출력)
(이제, 9개의 명령으로 code를 출력해준다.)
R4 -= R1
D4[]
0000

-------------------------------------------------

참고로, code + data 다 합쳐서 239자 이하가 되어야 한다... 

지금 위 structure를 참고하여 다시 식을 세워보면
f(x) = (18 + 11x)*ceil(3x+1/x+1)
239 이내는 택도 없다. 

-------------------------------------------------

관점을 바꿔서, 프로그램 흐름을 아래와 같이 바꿔보자. 

10: jump 한 줄
{
2t줄: data
1줄:  상수 jump
t줄:  code
1줄:  상수 jump
}

이러면 상수 jump를 한 번 더 출력해야 하므로 6줄 정도 추가 예상. (상수 jump 저장용 Registry가 필요)
f(x) = (24 + 11x)*ceil(3x+1/x)
... 이러면 놀랍게도 f(1)이 140이란다. 정말 될까? 실험 ㄱㄱ

-------------------------------------------------

10: jump 한 줄
{
2줄: data
1줄: 상수 jump
1줄: code
1줄: 상수 jump
}

바뀐 코드: 데이터는 항상 RE와 RF에 저장하는 걸로...
Free space: RB, RC

set R1 = 1
set R2 = 8
set R3 = 5
set R4 = ??
set R5 = 11
set R6 = C0
set R6 = R6 << 8
set R7 = !! (code -> code jump할 자리)
set R8 = []
set R9 = R6 + R7 (즉, R9가 C0!!이 됨)
set RA = R6 + R8
99FF (print 10:)
E500 (R5 자리, 즉 data 자리로 ㄱㄱ, 이제 다음으로 돌아오면 RE~RF가 잘 차 있음) ([]-1)
1553 (R5 증가시켜주기)
(이제, 8개의 명령으로 data를 출력해준다.)
9AFF (data에서 code로 넘어오는 부분 출력)
(이제, 3개의 명령으로 code를 출력해준다.)
RB = R6 + R7
9BFF (print jump)
R7 += 5 (by R3)
R4 -= R1
D4[]-1
0000

... -> 이론상 166줄 안에 되어야 한다!! 와~ 우승~

-------------------------------------------------

최종! 

!! = 14
[] = 51
?? = 20 (32회 반복)

<code>
7101
7208
7305
7420 ??
7511
76C0
5662
7714
7850
2967
2A68
99FF
E500 []
1553
7B7E ---> 8개의 명령 시작
5BB2
1BBE
9BFF
7B7F
5BB2
1BBF
9BFF ---> 8개의 명령 끝
9AFF
5EE2 ---> 3개의 명령 시작
1EEF
9EFF ---> 3개의 명령 끝
1B67
9BFF
1773
2441
D450
0000

<meta programming을 위한 주석 없는 코드>
7101
7208
7305
7420
7511
76C0
5662
7714
7851
2967
2A68
99FF
E500
1553
7B7E
5BB2
1BBE
9BFF
7B7F
5BB2
1BBF
9BFF
9AFF
5EE2
1EEF
9EFF
1B67
9BFF
1773
2441
D450
0000

-------------------------------------------------

물론 메타프로그래밍 하면서 조금씩 수정함. 
진짜 최종 코드: 

7101
7208
7305
7420
7511
76C0
5662
7714
7851
1967
1A68
99FF
E500
1553
7B7E
5BB2
1BBE
9BFF
7B7F
5BB2
1BBF
9BFF
9AFF
5EE2
1EEF
9EFF
1773
1B67
9BFF
2441
D450
0000